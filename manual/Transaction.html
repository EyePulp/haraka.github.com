<!DOCTYPE html>

<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <title>Haraka Manual &raquo; Transaction Object</title>
        <link rel="stylesheet" type="text/css" href="/reset.css">
        <link rel="stylesheet" type="text/css" href="/chapter.css">
        <link rel="stylesheet" type="text/css" href="/sh_emacs.css">
        <script type="text/javascript" src="/sh_main.min.js"></script>
        <script type="text/javascript" src="/sh_javascript.min.js"></script>
        <script type="text/javascript">
        window.onload = function () {
            var pres = document.getElementsByTagName("pre"),
                text;

            for (var i = 0; i < pres.length; ++i) {
                text = pres[i].innerText || "";

                if (!(/^\s*\$/).test(text)) {
                    pres[i].className = "sh_javascript";
                }
            }

            sh_highlightDocument();
        }
        </script>
    </head>
    <body>
        <div id="content">
            <h1>Transaction Object</h1>

<p>An SMTP transaction is valid from MAIL FROM time until RSET or "final-dot".</p>

<h2>API</h2>

<ul>
<li>transaction.uuid</li>
</ul>

<p>A unique UUID for this transaction. Is equal to the connection.uuid + '.N'
where N increments for each transaction on this connection.</p>

<ul>
<li>transaction.mail_from</li>
</ul>

<p>The value of the MAIL FROM command as an <code>Address</code> object.</p>

<ul>
<li>transaction.rcpt_to</li>
</ul>

<p>An Array of <code>Address</code> objects of recipients from the RCPT TO command.</p>

<ul>
<li>transaction.message_stream</li>
</ul>

<p>A node.js Readable Stream object for the message. </p>

<p>You use it like this:</p>

<pre><code>transaction.message_stream.pipe(WritableStream, options)
</code></pre>

<p>Where WritableStream is a node.js Writable Stream object such as a
net.socket, fs.writableStream, process.stdout/stderr or custom stream.</p>

<p>The options argument should be an object that overrides the following
properties:</p>

<pre><code>* line_endings (default: "\r\n")
* dot_stuffing (default: false)
* ending_dot   (default: false)
* end          (default: true)
* buffer_size  (default: 65535)
* clamd_style  (default: false)
</code></pre>

<p>e.g.</p>

<pre><code>transaction.message_stream.pipe(socket, { dot_stuffing: true, ending_dot: true });
</code></pre>

<ul>
<li>transaction.data_bytes</li>
</ul>

<p>The number of bytes in the email after DATA.</p>

<ul>
<li>transaction.add_data(line)</li>
</ul>

<p>Adds a line of data to the email. Note this is RAW email - it isn't useful
for adding banners to the email.</p>

<ul>
<li>transaction.notes</li>
</ul>

<p>A safe place to store transaction specific values.</p>

<ul>
<li>transaction.add<em>leading</em>header(key, value)</li>
</ul>

<p>Adds a header to the top of the header list.  This should only be used in
very specific cases.  Most people will want to use add_header() instead.</p>

<ul>
<li>transaction.add_header(key, value)</li>
</ul>

<p>Adds a header to the email.</p>

<ul>
<li>transaction.remove_header(key)</li>
</ul>

<p>Deletes a header from the email.</p>

<ul>
<li>transaction.header</li>
</ul>

<p>The header of the email. See <code>Header Object</code>.</p>

<ul>
<li>transaction.parse_body = true|false [default: false]</li>
</ul>

<p>Set to <code>true</code> to enable parsing of the mail body. Make sure you set this in
hook_data or before.</p>

<ul>
<li>transaction.body</li>
</ul>

<p>The body of the email if you set <code>parse_body</code> above. See <code>Body Object</code>.</p>

<ul>
<li>transaction.attachment_hooks(start)</li>
</ul>

<p>Sets a callback for when we see an attachment if <code>parse_body</code> has been set.</p>

<p>The <code>start</code> event will receive <code>(content_type, filename, body, stream)</code> as
parameters.</p>

<p>The stream is a <code>ReadableStream</code> - see http://nodejs.org/api/stream.html for
details on how this works.</p>

<p>If you set stream.connection then the stream will apply backpressure to the
connection, allowing you to process attachments before the connection has
ended. Here is an example which stores attachments in temporary files using
the <code>tmp</code> library from npm and tells us the size of the file:</p>

<pre><code>exports.hook_data = function (next, connection) {
    // enable mail body parsing
    connection.transaction.parse_body = 1;
    connection.transaction.attachment_hooks(
        function (ct, fn, body, stream) {
            start_att(connection, ct, fn, body, stream)
        }
    );
    next();
}

function start_att (connection, ct, fn, body, stream) {
    connection.loginfo("Got attachment: " + ct + ", " + fn + " for user id: " + connection.transaction.notes.hubdoc_user.email);
    connection.transaction.notes.attachment_count++;

    stream.connection = connection; // Allow backpressure
    stream.pause();

    var tmp = require('tmp');

    tmp.file(function (err, path, fd) {
        connection.loginfo("Got tempfile: " + path + " (" + fd + ")");
        var ws = fs.createWriteStream(path);
        stream.pipe(ws);
        stream.resume();
        ws.on('close', function () {
            connection.loginfo("End of stream reached");
            fs.fstat(fd, function (err, stats) {
                connection.loginfo("Got data of length: " + stats.size);
            });
        });
    });
}
</code></pre>

<ul>
<li>transaction.discard_data = true|false [default: false]</li>
</ul>

<p>Set this flag to true to discard all data as it arrives and not store in
memory or on disk (in the message<em>stream property). You can still access
the attachments and body if you set parse</em>body to true. This is useful
for systems which do not need the full email, just the attachments or
mail text.</p>

<ul>
<li>transaction.set_banner(text, html)</li>
</ul>

<p>Sets a banner to be added to the end of the email. If the html part is not
given (optional) then the text part will have each line ending replaced with
<code>&lt;br/&gt;</code> when being inserted into HTML parts.</p>

        </div>
    </body>
</html>
