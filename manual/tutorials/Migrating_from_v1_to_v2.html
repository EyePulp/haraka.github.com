<!DOCTYPE html>

<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <title>Haraka Manual &raquo; Migrating from Haraka v1.x to v2.x</title>
        <link rel="stylesheet" type="text/css" href="/reset.css">
        <link rel="stylesheet" type="text/css" href="/chapter.css">
        <link rel="stylesheet" type="text/css" href="/sh_emacs.css">
        <script type="text/javascript" src="/sh_main.min.js"></script>
        <script type="text/javascript" src="/sh_javascript.min.js"></script>
        <script type="text/javascript">
        window.onload = function () {
            var pres = document.getElementsByTagName("pre"),
                text;

            for (var i = 0; i < pres.length; ++i) {
                text = pres[i].innerText || "";

                if (!(/^\s*\$/).test(text)) {
                    pres[i].className = "sh_javascript";
                }
            }

            sh_highlightDocument();
        }
        </script>
    </head>
    <body>
        <div id="content">
            <h1>Migrating from Haraka v1.x to v2.x</h1>

<p>Haraka v2.x contains two significant changes to the v1.x API related to
streams.</p>

<p>Streams are an abstraction over a data flow that is provided by Node core
and is used throughout node to "pipe" data between two places or more. This
makes programming very easy, and is hence why we started using them in Haraka
starting with version 2.0.0.</p>

<p>For more information about the Stream API, see 
http://nodejs.org/api/stream.html</p>

<p>It's important to note that if you are using standard Haraka plugins then
it's very unlikely you will need to change anything. Though you may want
to configure <code>spool_dir</code> and <code>spool_after</code> in <code>config/smtp.ini</code>. However if
you have written custom plugins, continue reading.</p>

<h2>Changes To Look For</h2>

<p>Firstly, the incoming data in an email (the email body) is now stored in an
object which you can treat as a ReadableStream. To find if this is relevant
for you, look for instances of <code>data_lines</code> in your plugins.</p>

<p>Secondly, if you parse the mail body, attachments are now provided as a
stream, rather than custom start/data/end events. To find if this is relevant
for you, look for instances of <code>attachment_hooks</code> in your plugins.</p>

<h2>Fixing data_lines plugins</h2>

<p>Any plugins now working on each line of data will need to change to using a
stream. The stream is called <code>transaction.message_stream</code>.</p>

<p>These changes may be complicated if you are iterating over each line and
doing something with the strings therein. However if you are piping the data
to an application or over a network, your code will become significantly
simpler (and a lot faster).</p>

<p>In v1.x Haraka populated the <code>transaction.data_lines</code> array for each line of 
data received.  If you were writing the data to a socket then you had to handle 
backpressure manually by checking the return of <code>write()</code> and adding 
<code>on('drain')</code> handlers like so:</p>

<pre><code>var data_marker = 0;
var in_data = false;
var end_pending = true;
var send_data = function () {
    in_data = true;
    var wrote_all = true;
    while (wrote_all &amp;&amp; (data_marker &lt; connection.transaction.data_lines.length)) {
        var line = connection.transaction.data_lines[data_marker];
        data_marker++;
        wrote_all = socket.write(new Buffer(line.replace(/^\./, '..').replace(/\r?\n/g, '\r\n')), 'binary');
        if (!wrote_all) return;
    }
    // we get here if wrote_all still true, and we got to end of data_lines
    if (end_pending) {
        end_pending = false;
        // Finished...
        socket.send_command('dot');
    }
};
socket.on('drain', function () {
    if (end_pending &amp;&amp; in_data) {
        process.nextTick(function () { send_data() });
    }
});
</code></pre>

<p>In v2.x this now becomes:</p>

<pre><code>connection.transaction.message_stream.pipe(socket, {dot_stuffing: true, ending_dot: true});
</code></pre>

<p>This automatically chunks the data, handles backpressure and will apply any 
necessary format changes.  See <code>docs/Transaction.md</code> for the full details.</p>

<p>If you need to handle the input data by line, then you will need to create 
your own writable stream and then pipe the message to the stream and then 
extract the lines from the stream of data.  See <code>plugins/dkim_sign.js</code> for 
an example. </p>

<h2>Fixing attachment_hooks plugins</h2>

<p>For v1.x you passed in functions to <code>transaction.attachment_hooks()</code> as
follows:</p>

<pre><code>transaction.attachment_hooks(
    function (ctype, filename, body) {...}, // start
    function (buf) {...}, // data
    function () {...} // end
);
</code></pre>

<p>That has now changed to:</p>

<pre><code>transaction.attachment_hooks(
    function (ctype, filename, body, stream) {...}, // start
);
</code></pre>

<p>This allows you to attach the stream to other streams via <code>stream.pipe(dest)</code>.</p>

<p>Sometimes destination streams will apply backpressure on the sending stream,
for example if you are sending attachments to a remote service. In order
for this backpressure to apply to the connection itself (so that we don't
have to buffer up data in memory), we need to provide the connection object
to the stream:</p>

<pre><code>var transaction = connection.transaction;
transaction.attachment_hooks(
    function (ctype, filename, body, stream) {
        stream.connection = connection;
        ...
    }
);
</code></pre>

<p>For a full example of using attachment streams, see the Transaction.md
documentation file.</p>

        </div>
    </body>
</html>
